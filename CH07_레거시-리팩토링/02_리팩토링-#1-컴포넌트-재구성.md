## 리팩토링 #1 - 컴포넌트 재구성

```
1. 충전 지면 실행
2. 레거시 코드 리뷰
3. 개선 코드 리뷰
4. 진행과 인사이트
```

## 충전 지면 실행

다른 백엔드 서버들 모두 키고...
<br />

## 레거시 코드 리뷰 (`/web/webview2.1`)

코드는 전형적인 CRA 구조로 되어 있다.<br />
`src`하위를 보니까 `components`라는 폴더와 `App.js`가 있다.<br />
`components`폴더에는 `Countdown.js`, `Header.js`, `PageView.js`, `TokenBox.js`와 같은 컴포넌트들이 보인다.<br />
`App.js`을 열어보면 라우터 없이 하나의 단일지면으로 되있는 상태고 요즘은 잘 안쓰는 클래스 컴포넌트 형태로 되어 있다. `PageView`, `Header` 컴포넌트들을 사용하고 있는데, `PageView`에 들어가보면 ShowCase앱에서 만들었던 컴포넌트와 유사하다. 차크라UI 쓰는 건 똑같고, 그렇지만 다른 점은 역시 클래스 컴포넌트로 되어있다라고 하는 점. 그리고 `Header` 네비게이션 헤더로 구성하는 컴포넌트인데, 다른 점은 또 클래스 컴포넌트로 되어 있다라는 것정도가 보인다.<br />
그리고 `TokenBox`라고 하는 컴포넌트가 있는데, 이 `TokenBox` 컴포넌트는 `CountDown`이라는 컴포넌트를 불러다가 사용하고 있다. 이 컴포넌트는 무엇을 하는 컴포넌트일까. 토큰 충전 페이지에 두 개의 박스가 있는데, T12짜리 박스와 T24 박스 이 두개의 박스를 만들어내는 컴포넌트다. 그래서 이 description을 두 가지, 'PrimaryDescription', 'SecondaryDescription' 두 가지 함수 컴포넌트가 있고, 이건 또 함수 컴포넌트인데, description이 달라서 컴포넌트 분할을 해놓은 것으로 보인다. 그리고 나서 render하면서 외부에서 사용할 때 chargeType이 Primary냐 아니냐에 따라서 맞게 보여주는 평범한 코드로 되어있다. App.js에서 저 props를 주고있다.<br />
그리고 버튼, 기본적으로는 Primary면 '토큰 충전' 아니면 카운트다운을 하는 식으로 되어 있다. `Countdown`컴포넌트로 들어가보자.<br />

`Countdown`컴포넌트 역시 클래스 컴포넌트로 되어 있고, 클래스 컴포넌트의 상태를 갖고 있는 컴포넌트다. 그러다 보니 당연히 라이프 사이클과 연관된 부분들이 많이 있다. componentDidMount나 componentWillUnmount등의 라이프 사이클 메소드들이 구현이 되어 있고, componentDidMount에 setState를 이용해서 interval도 있다. 왜냐하면 discount로 계속 시간을 거꾸로 줄여나가야 되니까 interval 코드도 존재하고, 그 안에서 카운트 다운과 관련된 값들을 setState를 이용해서 업데이트를 하는 형태로 되어 있고, render 코드가 있다.<br />
기본적으로는 굉장히 간단한 코드인데, 어쨌든 클래스 컴포넌트로 되어 있고 그러다 보니 상태를 쓰려면 이렇게 복잡한 라이프 사이클 메소드들을 구현을 해내야 된다. 그래서 클래스 컴포넌트로 구현되어 있는 부분들. 요즘 리액트가 훅 베이스로 굉장히 다양하고 심플하게 로직을 구성할 수 있는데, 얘는 그러지 못하고 있다. 토큰 박스 컴포넌트 안에는 상태가 없는데, 카운트다운 컴포넌트는 상태를 갖고 있고 이 상태가 다 코드로 읽어야 되니까 라이프 사이클 메소드를 쫓아다니면서 대체 이 컴포넌트가 갖고 있는 state의 이 값이 어떤 식으로 업데이트가 되는지를 쫓아가기가 조금 버거운 느낌이다. 샘플이라 간단한 코드만 있긴 하지만, 이 상태에서도 '어떻게 돌아가는거야' 라고 알기가 쉽지 않다. 컴포넌트와 저 카운트다운을 하는 로직이 분리가 안 되어 있고 뒤섞여 있다 보니까 그러한 문제점들을 발생시킨다. 그리고 최신 버전의 훅을 쓰고 싶어도 클래스 컴포넌트로 되어 있으니까 훅 패턴을 쓸 수도 없는 상황이다.<br />

그러면 결국, 이 전체를 리팩토링해야 하겠구나 라는 생각을 하게 된다.<br />

또 하나 `PageView`나 `Header`같은 컴포넌트들을 보면, Showcase 개발할 때도 컴포넌트로 만들어놨던 바로 그 컴포넌트들이다. 그런데 여기에 그냥 코드 자체로 들어가 있다. 이게 컴포넌트의 스코프가 서비스나 프로덕 기준의 스코프가 되지 못하고 프로젝트 기준의 스코프가 되고 있다는 이야기다.<br />
이런식으로 되어 있다 보니 Showcase에 있는 `PageView`나 `Header`를 가져다가 쓸 수 있는 방법이 없다. 그래서 이것도 한번 개선을 해보자라고 하는 게 이번 리팩토링의 핵심 과제 중의 하나다.

- 클래스 컴포넌트를 함수 컴포넌트로.
- 프로젝트 스코프의 컴포넌트를 서비스, 프로덕 스코프의 컴포넌트로 사용하자.

<br />

## 개선 코드 리뷰 (`/web/webview2.2`)

package.json을 살펴보면, 크게 차이는 없고 한 두가지정도 차이가 있다.<br />
코드를 살펴볼 때 보면 클래스 컴포넌트가 함수 컴포넌트로 바뀌어 있는 것 그리고 `@12shop/components`라고 하는 컴포넌트가 들어가 있다. 지난번에 했던 logger 라이브러리 하는 것 처럼 똑같이 파일로 연결되어 있는 형태로 일단은 되어 있다.(`file:../12shop-components`)<br />
그러니까 컴포넌트가 분리가 되어 있다. 애초에 `12shop-components`가 있다. 하위를 보면 `lib/`밑에 `Header`와 `PageView`. 두 개의 컴포넌트가 보이는 것을 확인해볼 수 있다. 이걸 가져다가 기본적으로 이 웹뷰 컴포넌트로 사용하게 된다.<br />

코드를 살펴보자.<br />
`src` 밑에 `CountDown`과 `TokenBox` 두 개의 컴포넌트밖에 없는 걸 볼 수 있다. 기존의 2.1을 보면 `PageView`와 `Header` 컴포넌트들이 있는 걸 볼 수 있는데, 이게 `12shop-components` 리포로 다 빠져버린 것이다. 이제 기본적으로 컴포넌트 리포가 완전히 분리돼서 효과적으로 개발할 수 있게 되는 구조가 만들어져 있는 것이다.<br />
`App.js`를 보면 함수 컴포넌트로 변경된거 말고는 특별하게 달라진게 없다. `TokenBox`도 마찬가지고, 이렇게 함수 컴포넌트로 바뀌니까 달라진 점은 기존의 `Countdown` 컴포넌트도 클래스 컴포넌트 였는데, 함수 컴포넌트로 바뀌면서 드디어 함수 컴포넌트의 장점인 hook을 사용할 수 있게 됐다. 기본적으로 라이프 사이클 메소드가 없이 hook으로 심플하게 `useCountdown`이라고 하는 custom hook을 만들어서 모든 로직이 그 hook 안에 모아 응집성을 높일 수 있게 됐다. 기존의 클래스 컴포넌트 같은 경우에는 라이프 사이클 메소드로 코드가 분화되어 있어서 라이프 사이클에 대한 이해도 필요하고 그리고 그 안에서 어떤 흐름으로 어떤 로직이 어떻게 상태가 변해가야 되는가를 리딩을 해야 하는데, 얘는 기본적으로 그냥 하나의 카운트다운이라고 하는 함수 하나에 모여있으니까 그냥 쭉 읽으면 된다. 물론, useEffect같은 hook의 작동 원리를 이해하고 있다는 전제가 좀 필요하긴 하지만 요즘은 다 이렇게 hook을 이용해서 리액트 같은 경우에는 개발을 하니까 충분히 가독성이 높아졌다라고 생각해 볼 수 있을 것 같다. 그래서 나머지 로직들은 비슷하고 이렇게 컴포넌트를 함수 컴포넌트로 리팩토링을 했다.<br />

`App.js`를 다시 보면, `TokenBox`는 내부에 있는 컴포넌트를 사용하고 있고, `PageView`와 `Header`. 즉, 프로젝트 범위. 리파지토리 스코프가 아닌 서비스 범위의 12shop 컴포넌트 리포를 임포트를 해서 `PageView`, `Header` 두 개의 컴포넌트를 쓰고 있다. 이렇게 만들어 놓으면 당연히 웹뷰 2.1에서도 쓸 수 있고, 1.1(Showcase)에서도 쓸 수 있게 된다. "즉, 쇼케이스 지면과 충전 지면에서 똑같은 컴포넌트를 쓰게 된다. 그러면 저 `PageView`의 새로운 스펙이 업데이트 됐다고 하면 개별 프로젝트들에서는 버전업을 npm 업데이트를 해서 받아오고, 그 관련된 내용들을 적용해서 바로 배포가 나가면 되니까" 훨씬 더 효과적으로 개발을 할 수가 있게 된다. 그런 환경이 이렇게 비로소 구축이 됐다라고 할 수 있다.

<br />

### 진행과 인사이트 (Progress & Insight)

```
# Progress & Insight
(※ 진행하는 내용들을 업데이트하고 우리가 처음의 계획 단계에서는 예측하지 못했던 실제 진행단계에서는 일어나고 그런 것들을 어떻게 처리할 것인가 또 잘 처리하는 개발자나 조직이 훌륭한 조직이라고 좋은 조직이라고 이야기를 했는데, 그런 맥락에서 문제들을 살펴보자면)

· 긍정
  · 공통 컴포넌트 리포 개발로 프로젝트별 중복 컴포넌트 35개가 제거됨. (※ 물론 샘플에서는 2개의 컴포넌트를 예로 들었지만 ^^; 실제라면 35개 곱하기 프로젝트 갯수니까 엄청난 개선을 이뤄냈다고 할 수 있다.)
· 개선 필요
  (※ 이렇게 진행을 하다 보니 이런 문제가 생기더라는 것이다. 공통 컴포넌트의 개발 주체가 굉장히 '모호'하다. 그래서 커뮤니케이션 코스트가 지속적으로 발생한다. 그러니까 공통 컴포넌트를 개발 운영하는 역할을 부여 받은 전속 팀 할당이 필요하다 라고 의견까지 추가적으로 들어가 있다.)
  (※ 이게 무슨 이야기일까? 리포로 한번 다시 돌아가보자. 12shop-components라고 하는 공통 컴포넌트 리포가 생겼다. 이거는 예제니까 하나의 디렉토리 안에 하위로 모두 다 같이 들어가 있어서 독립된 리포로 보이진 않지만 실제 회사라고 하면 현실에선 이게 독립된 리포로 분리되어 있을 것이다. 그러면 '이 리포를 누가 관리하고 개발하고 운영할 것인가?'에 대한 문제가 생긴다. 쇼케이스 개발을 하는 팀도 있고, 또 충전 지면을 개발하는 팀도 있을 테고 그 외에 여러 가지 웹 애플리케이션을 개발하는 팀들이 도메인 별로 나눠져 있을 공산이 큰데, 이 12shop 컴포넌트 리포는 어느 팀에서도 다 해도 되지만, 그렇기 때문에 어느 팀도 안 할 수가 있는 것이다. 각 팀에는 각 팀의 가장 최우선 우선순위가 항상 있기 마련이니까 이런 류의 공통 작업들은 항상 우선순위에서 좀 밀리는 측면들이 좀 있다. 그런 일들이 빈번하게 일어난다고 하면, '이 페이지뷰와 헤더 컴포넌트 같은 것이 바뀌어야 돼'라고 한다면 디자인 쪽에서 뭔가 먼저 커뮤니케이션이 될 것이다. 그러면 개발 주체가 어딘지, 어느 팀이 이걸 개발해. 라고 하면 모든 팀이 할 수 있지만 반대로 명확하게 어떤 팀이 해야 한다는 역할이 부여 받지 않아서 '그쪽에서 할래요?', '이쪽에서 할께요' 이런 커뮤니케이션이 필요하고 또 상황에 따라서는 주로 이 컴포넌트 리포를 빌드업 하던 팀이 아닌 한 번도 안 해봤던 팀이 시간 여력이 있어서 이 컴포넌트 리포를 변경하는 상황이 됐을 때는 또 뭔가 코딩 컨벤션이 좀 달라 질수도 있고 혹은 이 컴포넌트를 변경하고 어떻게 등록해야 되는지 또 어떻게 알려줘야 되는지에 대한 프로세스 같은 것들도 익숙하지 않아서 시간이 더 많이 걸릴 수도 있고 여러가지 문제들이 생길 수 있다. 그런 측면에서 이렇게 공통 리포가 생기면 명확하게 이 역할 이 리포를 운영 할 역할을 특정 팀에 딱 할당해 놓는 게 굉장히 좋다. 그래서 이렇게 프로젝트를 진행을 하면서 프로젝트 리포들의 분리된 상황과 조직 운영과도 사실 일하는 방식과 밀접한 연관이 있기 때문에 이런 부분들 면밀히 잘 관찰하고, '우리 조직이 어떤 식으로 비효율이 발생하는가', 현재 일하는 방식과 시스템 구조와 차이점 때문에 발생하는 일들과 같은 부분들도 잘 튜닝을 해서 적절하게 배치되고 적절하게 역할이 부여받을 수 있게끔 해야 한다라는 이야기.)
  · 공통 컴포넌트 리포의 개발 주체가 모호하여 커뮤니케이션 코스트가 지속적으로 발생함
    · 공통 컴포넌트를 개발 운영하는 역할을 부여받은 전속 팀 할당 필요
  · ...
```

이렇게 구조적인 측면에서 리팩토링을 해봤는데, 다음 세션에는 미시적으로 어떤 특정 기능을 한번 바꿔보는 리팩토링을 하면서 추가적으로 지금까지는 npm을 파일로 링크 연결 방식으로 했었는데, 직접 npm 프라이빗 리파지토리에 등록해놓고 그걸 가져다 쓰는 것도 한번 같이 보도록 하자.
