## 기술 스택 선택 - SSR VS CSR

```
1. Presentation 파일
2. SEO
3. Web Vitals
4. 선택의 시간
```

### 꼭 기억해야 하는 것

프로젝트를 시작할 때 항상 요구사항이 있고, 그 요구사항에서 기술적인 선택을 하게 된다.<br />
그 중에서 가장 먼저 기억해야할 것은 무엇인가?<br />
바로 "`프로젝트 요구사항`에서 시작하자!"는 것이다.

```
Q. "그 기술을 왜 선택했어요?"<br />
A. "이 기술을 외부에서 굉장히 많이 쓰는 것 같드라구요~"<br />
A. "여러 사람들이 이 기술이 좋다고 하더라구요~ 그래서 내가 안해봤는데 이걸 한번 해보고 싶었어요. 그래서 이번에 프로젝트를 하는 김에 이 기술을 한번 선택해봤어요~"<br />
혹은 "이런 프로젝트 유형은 이 기술로 하는 것 아닌가요?"<br />
...😣<br />
가장 최악의 유형의 엔지니어 상이라고 할 수 있다.
```

그럼 요구사항에서 출발하는데, 어떻게 출발할 것인가?<br />

1. 서비스가 더 많은 사용자에게 노출될 수 있도록 한다.<br />
2. 사용자에게 더 많은 서비스 정보를 제공한다.<br />
3. 사용자에게 서비스의 매력을 증진시킨다.

> 12shop Showcase for Web RFC / 개발 / 핵심 목표

🤔 "Keyword...?"

- 더 많은 사용자 노출

  - [SEO(Search Engine Optimization)](https://en.wikipedia.org/wiki/Search_engine_optimization)<br />
    URL을 통해 사용자에게 전달되는 웹 서비스. 이 URL이 웹앱의 가장 큰 단점 중의 하나다. 사용자한테 서비스 자체를 알려주기가 굉장히 힘들다. 보통 앱 같은 경우에는 앱스토어에 모두 올라가 있고, 여러 가지 형태로 보여질 수 있다. 이번주의 핫한 앱, 혹은 사용자한테 많이 다운로드 받은 앱, 등등 여러 가지 형식으로 사용자들한테 전달을 해주는데 웹은 그런게 없다. 그냥(!) 웹서버에 도메인 주소 연결시켜 띄워놓고 사람이 오기를 기다리는 게 다일 뿐인다. ^^; 그 외에는 엄청난(!) 마케팅 비용을 써서 광고를 집행하거나 뭐 이런 경우인데, 그렇지 않은 경우에는 사용자들이 구글이나 네이버와 같은 검색엔진, 즉 검색을 통해서 진입하게 되는 경우가 태반일텐데, 그럼 검색엔진에 잘 노출될 수 있도록 하는 일련의 통합적인 여러가지 행위들 혹은 기술적인 구성들 이걸 'Search Engine Optimization'이라고 부른다.<br />

    실제로 "SEO에 대해서 설명해 보세요"라고 하면, 굉장히 피상적인 내용을 이야기하는 사람들이 많다. 왜 피상적인 표현들을 하는지에 대한 원인을 살펴보자면, 학습이 제대로 안 되어 있어서 그렇다. 학습도 이렇게 우리가 학교 다닐 때 학습하는 것처럼 공식을 달달달 외우거나 이런 학습이 아니라, 실질적으로 이 기술에 대해서 탐색해 보고 탐닉해 보고, 실제의 경우에 따라서는 실행도 해보고 테스트도 해보고 그러면서 내 걸로 체화돼서 완전히 이해가 된다고 하면, 암기하지 않는다고 하더라도 논리적으로 여러 가지 것들을 떠올려 볼 수 있을 것이다. 우리는 학교 다니는 그런 교과 수업으로 하는 게 아니니까 말이다. 그런데 그런 것들을 해보지 않고 어디서 "음~ SEO가 이런거구나"하면서 요약본 같은 것들을 간단하게 한번 살펴보고 지나간다고 하면 사실 내 것이 될 수 없고, 누군가가 SEO가 어떤건가요라고 질문했을 때, 피상적인 대답밖에 할 수가 없는 것일 것이다.<br />
    이와 같은 측면에서 우리는 프로젝트 시작 지점에 여러 가지 기술들에 대해서 고려를 해야 하는 지점(활동)들이 있는데, 이 활동이 핛브을 하기에 절호의 찬스(!)니까 이 시간을 아주 적극적으로 활용하는 것이 좋을 것이라 생각한다. 🙂

    > Increasing prominence(어떻게 하면 검색엔진에 잘 부각시킬 수 있고, 그 요소가 무엇인가를 다루고 있는 섹션.)의 핵심적인 키워드<br />
    >
    > - Cross linking (링크가 많은 문서에 대해 랭킹을 올리는 알고리즘, 웹 앱의 페이지 내에 다양한 링크들이 잘 정리 정돈돼서 서로 간의 레퍼런스를 잘 맺고 있는지와 같은 것들을 검색엔진이 탐색한다는 것.)
    > - title tag and meta description (타이틀도 잘 다뤄야하고, html 페이지 내의 메타 태그에 대한 것들도 굉장히 정교하게 잘 달려 있어야 결국 이 웹사이트의 퀄리티를 높은 수준으로 평가한다. 점수가 높게 나오니까 당연히 점수가 낮은 페이지보다는 앞에 노출 될 것이다. 검색엔진에서 랭킹을 올릴 수 있는 항목 중 하나다.)
    > - URL canonicaliztion(URL 정교화, 엔지니어가 아니면 잘 다루지 않고 이거에 대해 잘 처리하지 않는 경우들이 많다. 간단히만 이야기하자면, 똑같은 컨텐츠라고 하더라도 URL이 굉장히 다양하게 표시될 수 있다. 구글만 하더라도 google.com이 있고, www.google.com, google.com/ 도 있고 하는... 이와같은 URL이 서로 다른 URL로 인지될 수도 있다. 하지만, 실제로는 구글닷컴 하나로 인지되면 가장 좋을 것이다. 유니크한 컨텐츠를 하나로 잘 정리 정돈 하는 것. 이런 부분들에 대해서 다루고 있다.)

    결론,<br />

    - HTTPS version (Secure Site)
    - Page Speed
      - [https://pagespeed.web.dev/](https://pagespeed.web.dev/)
    - Structured Data
    - Mobile Compatibility
      - [https://search.google.com/test/mobile-friendly](https://search.google.com/test/mobile-friendly)
        <br />

    오픈 그라피가 잘 되려면 어떻게 해야할까?<br />
    메타 태그가 잘 기록되어야 할테고, 당연히 컨텐츠에 따라서 메타 태그가 달라질 수도 있을 것이다. 그러면 컨텐츠마다 달라지는 메타 태그를 검색엔진한테 제공해 줄 수 있는 기술 스택이 되어야 할 것이다. 그런 측면들을 우리가 지금 하고 있는 기술을 선택하기 위한 포인트. 추출해 내야 되는 포인트들이라고 할 수 있다.

    - 위에서의 `meta description` 관련 중요한 키워드. 바로, [Open Graph Protocol](https://ogp.me/)다.<br />
      - OpenGraph Guide<br />
        - [Facebook](https://developers.facebook.com/docs/sharing/webmasters/)
        - [Twitter (Twitter Card)](https://developer.twitter.com/en/docs/twitter-for-websites/cards/guides/getting-started)

- 매력을 증진

  매력을 기술로서 어떻게 사용자들에게 전달할 수 있을까?<br />
  showcase를 처음 만드는 지금과 같은 상황에서 UX는 디자이너와의 협업과 오랜 기간의 테스트를 거쳐야 될 필요가 있다. 만들면 좋기야 하겠지만, 첫 번째부터 시작해서 최고의 UX를 만들기는 어려울 것이다. 이 부분을 우리의 영역이 아니라고 보고 배제한다고 하면, 엔지니어로서 할 수 있는건 뭐가 있을까? 결국 성능. Performance. 빠릿빠릿한 웹앱을 개발하는 것. 이게 핵심일 것 같다. :)<br />

  "퍼포먼스를 다루는 것은 어떤게 있을까?" <br />
  퍼포먼스를 다루는 여러 지표들을 취합해서 모아놓고, 이렇게 성능 튜닝을 하면 좋다거나, 성능 튜닝을 하는데 단지 "빠르다!", "느리다!"와 같이 한다면 그건 객관적인 지표가 될 수는 없을 것이다. 그리고 튜닝하기도 굉장히 추상적이기도 하고, "어디를 어느 지점의 어떤 식으로 튜닝할 것인가?"에 대한 목표가 불분명하기 때문에 이것들을 지표화해서 개별 지표들을 개발하고, 그 각각의 지표들에 대해서 "어떤 식의 튜닝하는 방식들이 유용한가?"와 같은 것들을 제한해 놓은 스펙이 있는데, 그것이 [웹 바이탈](https://web.dev/i18n/ko/vitals/)이다.<br />

  앞에서 페이지 스피드라고 하는 사이트에서 웹 사이트 테스트를 구글도 해보고 네이버도 해봤는데, 구글 같은 경우는 맨 앞부분에 웹 바이탈과 관련된 부분들이 Pass라고 나와 있고 네이버 같은 경우에는 Fail이 나왔다. 바로 그 웹 바이탈이다.

  - Largest Contentful Paint(최대 콘텐츠풀 페인트, LCP) - Loading<br />
    여러 가지 UI 구성요소들이 하나의 페이지에 들어가 있는데, 그 중에 가장 큰 컨텐츠가 표시되는 시점까지 걸린 시간을 LCP라고 한다. 이전에는 FCP(First contentful paint)라고 해서 사용자한테 웹 사이트가 전달될 때, 최초로 하얀 화면에 무언가가 탁(!) 페인팅 될 때. 즉, 렌더링이 되는 그 시점까지의 시간이 얼마나 걸리느냐를 측정했는데 이걸 요즘에는 잘 안 쓰고 LCP를 다루는 경우가 많다. 왜냐하면 어찌 됐든 아무리 작은 요소라도 하나만 표시가 되고 나서 사용자가 '아 이 서비스가 뭐야'라고 인지할 만큼의 모양이 아직 드러나지 않았는데, 점 하나 찍혔다고 해서 빠르다고 하면 문제가 되는 일이기 때문이다. 점 하나 찍히고 3초후에 이미지가 떳다면, 그제야 사용자가 이 웹사이트가 뭐 하는 데구나라고 인지하는거지 점을 보고서 인지하는건 아니기 때문이다. 또 로딩스피너 같은 사례도 있을 수 있고... 문제가 있는 지표로 여겨지면서, LCP를 많이 쓰고 있다.
  - First Input Delay(최초 입력 지연, FID) - Interactivity<br />
    사용자가 어떤 인터랙션(링크를 클릭하거나, 버튼을 클릭하거나)를 했을 때, 얼마나 빠르게 반응하는가를 측정하는 지표다.
  - Cumulative Layout Shift(누적 레이아웃 시프트, CLS) - Visual Stability<br />
    웹 페이지에 화면이 구성될 때, 기본적으로 모든 리소스가 로딩된 뒤에 렌더링이 이루어지지 않는다. 전부 다 비동기적으로 호출되기 때문에 화면의 레이아웃이 막 타닥 타닥(!) 조립되는 모습이 보인다. 그런 조립되는 모습. 그것은 결국 사용자가 어떤걸 클릭하려고 뭔가를 하려고 했는데, 화면 레이아웃이 시프트 되면서 그 링크가 밑으로 훅 내려간다거나 하면 사용자들은 불편한 경험을 하게 될 것이다. 그렇게 사용자의 레이아웃이 흔들림 정도가 어느 정도 되는가?를 측정하는 지표다. 당연히 안정적으로 안 흔들릴수록 좋은 것일 것이다. 😅

  위 세가지 모두 크롬의 개발 툴에서 확인이 가능하다.(Inspector의 Performance 탭.)

  웹 프론트엔드 개발자라고 한다면, 이런 성능지표들이 굉장히 중요하다. 그리고 저런 성능 지표들을 튜닝하기 위해서 필요한 여러 가지 지식들을 학습하면서 지식도 늘어갈 수 있고, 경험도 풍부해지고 또 성장도 자연스럽게 되는 거고... 넓고, 깊게, ...🙂

<br />

### 선택의 시간 ⏰

#### Showcase 웹앱은 무엇인가?

간단한 서비스 소개와 앱 다운로드 링크만을 제공하는 현재의 12shop.com 모바일웹 사이트에 앱에서 제공하는 쇼케이스 지면의 웹 버전을 개발한다. 웹으로 접근하는 사용자에게 보다 더 많은 서비스 정보를 제공함으로써 서비스 소개 역할을 확대하고 서비스로 진입하는 사용자 수 확대에 기여한다.

> 12shop Showcase for Web RFC / 프로젝트 개요

### 선택 1. CSR vs. SSR (핵심 구현 방식, [https://web.dev/rendering-on-the-web/](https://web.dev/rendering-on-the-web/))

> 핵심 구현 방식? 여러 가지 기술 구성과 관련한 가장 많은 영향력을 끼치는 것이라고 정의해봄.

#### CSR

장점

- Backendless <br />
- CDN, Cache, Traffic<br />
  백엔드가 없어도 되는 점. (물론 CSR이여도 서버를 사용하는 경우도 있고 아닌 경우도 있다.)<br />
  최근 추세는 CSR의 큰 장점은 결국 모든 애플리케이션 코드가 자바스크립트 하나의 번들 파일 안에 다 들어가 있다는 것인데, 그 번들 파일은 자바스크립트 파일이고 그 자바스크립트 파일만 있으면 웹 애플리케이션을 구동시킬 수 있는 것이다. 그런데 문제는 자바스크립트 번들 파일 자체를 서빙 할 서버가 필요한 부분이다. 그 서빙할 용도의 웹 서버를 두는 경우도 있지만, 요즘은 굉장히 많은 CDN 서비스들이 있다. 이런 CDN 서비스들을 이용하면 서버리스한 아키텍처를 구현할 수 있는 것이다. (CDN에 잘 배포하는 배포전략만 세운다면 말이다 ^^;)<br />

  백엔드가 없다는건 어떤걸 의미할까?<br />
  트래픽. 즉, 서버 다운과 관련된 장애에서 상당 부분 자유로워질 수 있다는 것이다. 백엔드가 없으면 이 번들 파일에 서빙을 CDN서비스에 맡길 텐데, 대부분의 CDN서비스는 트래픽을 다 감당하는 데 최적화된 서비스들이다. 그래서 우리가 백엔드를 운영하는 것보다 훨씬 더 장애가 안날 여지가 많고, 그리고 그마저도 실제로 장애가 나는 데에 대비해서 이중화 하기에도 굉장히 쉬운 구조들을 제공하고 있기 때문에 "서버리스로 서비스를 구축할 수 있다."라고 하면, 굉장히 큰 이득이다.<br />

  24시간 서버를 운영하는 것도 엄청난 스트레스이기 때문에 CSR의 가장 큰 장점은 아무래도 Backendless일 것이다. 🙂 <br />

  만약 CSR 서비스를 운영하고 있는데, 백엔드가 있는 상태로 운영하는 아키텍처를 가지고 있다고 한다면 최대한 빨리 백엔드가 있어야 될 이유들을 제거하고, Backendless 서비스로 전환하는 것을 한번 검토해보면 좋을 것이다. 개인적으로는 여러 가지 운영을 해보니까 기본적으로 CSR의 가장 큰 장점. 백엔드가 없는 건데 백엔드가 있이 운영하는 건 거의 절반 이상의 CSR의 장점을 날려버리고 쓰는 게 아닌가라는 생각이 든다. 물론 아주 작은 서비스는 크게 상관없겠지만, 서비스가 커지면 커질수록 엄청난 운영 비용이 들기 때문이다. 그리고 스트레스도. 굉장히 심하다. 이와같은 측면에서 첫 번째 Backendless가 CSR에 가장 큰 장점으로 보이고, 이 Backendless가 되니까 당연히 CDN도 이용할 수 있고 Cache도 전략을 이용할 수 있기 때문에 번들파일을 사용자들한테 훨씬 더 빨리 디리버리 할 수 있을 것이다. 그리고 당연히 트래픽에 엄청난 강점을 가진다는 점이 있다. 물론 트래픽은 결국 트래픽이 생기는 서비스에서만 커질 테니까, 내가 하루에 한 만 명 정도 들어오는 서비스를 운영하고 있다면, 사실 트래픽이나 아키텍처가 어떻게 됐든 간에 사용자들한테는 크게 체감할 수 없고, 운용비용도 그렇게 크지 않을 것이다. 하지만 10만명, 100만명, 1000만명 단위로 넘어가면 전혀 다른 차원의 문제들이 되므로 이런 측면들도 고려해야 한다.

- 초기 로딩 후 빠른 인터랙션

<br />

단점

- 초기 로딩 최적화에 많은 비용이 든다.<br />
  초기 로딩 최적화라고 하면, 사용자한테 제공되는 번들 파일 자체가 크면 클수록 당연히 초기 로딩 속도가 느려질 수밖에 없다. 웹 바이탈 점수가 처참하게 떨어질 수밖에 없는 상황이 생길 수 있다는 이야기가 된다. ^^; 그래서 초기로딩에 튜닝을 많이 해야 되는데, 이게 한계가 있다. 웹앱이 점점 시간이 흘러 갈수록 기능의 물리적인 크기도 커질 수밖에 없는 것이다. 크기는 고정인데, 기능은 점점 풍성해지는 것은 불가능한 이야기니까. 어떤 식으로든 튜닝을 해야 하는데 굉장히 다양한 기술적 어프로치를 해야하는 측면들이 있다. 그럼에도 불구하고 한계가 있을 수 있다는 측면에서 초기 로딩 최적화를 시도할 때 많은 비용이 든다는 게 CSR의 가장 큰 단점으로 보인다. (물론, 마찮가지로 앱이 작으면 크게 문제 되지 않을 것이다. 😅)

- SEO 대응에 한계가 있다.<br />
  SEO를 위한 검색엔진은 보통 크롤러들이 웹 서버에 접속을 해서 정보를 읽어가는데 이 크롤러에 따라 자바스크립트를 실행한 다음에 정보를 읽어가는 반면, 그렇지 않은 경우들도 많고, 또 자바스크립트의 실행이 무한정 크롤러가 기다릴 수가 없으니까 실행이 좀 늦거나 여러가지 문제가 생겨서 아무런 정보도 없는 빈 html 파일을 읽어가는 경우도 있기 때문에 그런 측면에서 SEO 대응이 한계가 있다 라고 할 수 있다. 아주 못하는 건 아닌데, 완벽하게 대응하기에는 구조적으로 기술적으로 문제가 있다라는게 CSR의 단점 중 하나다.

- 멀티 도메인 API 연동시 추가 아키텍처가 필요하다.(CORS, Gateway Server)<br />
  웹앱이 실제 백엔드사이드의 도메인 API 서버가 한 두개 연동된다라고 하면 사실 크게 문제가 되지 않는데, 뒤단의 서버. 즉, 많은 정보들을 처리하고 다양한 기능들을 사용자한테 제공하게 될 때, 서비스가 커지면 커질 수록 백엔드사이드의 도메인들이 좀 분리가 되는 경우들이 있다.<br />
  작은 단계에서는 하나의 API 서버가 모든 정보들(회원정보, 제품정보, 사용자 정보 등등)을 다 제공해 주지만 서비스가 커지면 커질수록 이 도메인 서버들이 분리돼서 마이크로 서비스화 되는 경향이 있다. 그랬을 경우에 API의 엔드포인트들이 다 달라지는 상황이 생기고 이 엔드포인트가 달라지면 웹앱 같은 경우에는 도메인 보안정책으로 다른 도메인의 API를 Ajax로 호출하기 어려워진다. 그래서 CORS 세팅을 한다거나 혹은 게이트웨이 서버를 둬서 게이트웨이 서버 역할을 하는 애가 여러 가지 API를 중개해 준다거나, 이런 아키텍처로 만들어야 되는데 보안적인 문제도 있을 수 있고, 구성상의 복잡도가 생길수도 있고, 여러 가지 문제가 생길수도 있다.<br />
  즉, "불필요하게 복잡해질 수 있다"라고 하는 측면들. 이게 또 CSR의 단점 중 하나다.

<br />

#### SSR

"사용자에게 전달할 html을 누가 만드는가?" → 서버<br />
서버 사이드 렌더링 🙂 <br />
클라이언트 사이드 렌더링은 자바스크립트가 조립하는거고, 서버 사이드 렌더링은 서버에서 조립하는 거고 🙂

장점

- SEO 대응이 용이하다.<br />
  크롤러가 접근하나 브라우저가 접근하나 결국, HTML 첫 번째 페이지에 대한 조립을 서버에서 하기 때문에 똑같은 상황이 되는 것. 그래서 메타 태그에 대한 적절한 세팅이라던가 컨텐츠에 대한 완전한 html을 크롤러나 혹은 브라우저한테 온전히 다 전달해줄 수 있는 기본적인 아키텍처를 갖고 있기 때문에 SEO를 대응한다라고 하면 당연히 완벽하게 대응할 수 있는 기본 아키텍처가 된다.
- 빠른 초기 로딩(무조건은 아니다)
  CSR과 달리 번들 파일이 최소화 된다. 하나의 웹앱에 모든 것을 번들 자바스크립트 파일 하나에 묶는 게 아닌 구조기 때문에 첫 번째 페이지 로딩할 때 사용자한테 전달되어야 할 에셋들이 굉장히 작다. 그래서 빠른 초기 로딩이 가능하다. <br />
  물론, 무조건적인건 아니다. 서버 사이드 렌더링 함에 있어서도 뒤단의 완벽한 html을 만들기 위해서 API 서버와의 호출도 일어나야 되고 여러 가지 일들이 많이 일어날 수 있는데, 그것 자체가 느리다고하면 제 아무리 SSR이라고 하더라도 html을 조립을 못하니까 당연히 첫 번째 인터랙션이 느릴 수밖에 없다. 그러니까 SSR을 선택했다고해서 무조건 빠른 건 아니다. 백단의 API 서버. 즉, 화면을 렌더링하기 위해서 필요한 API 서버가 느리면 다 무용지물이다. 이런 측면에서 고려해볼 필요도 있다. "내가 연동할 서버의 성능이 어떤가?" 그 성능이 되게 느리다. api response가 한 2초쯤 된다. 그러면 내가 SSR로 아무리 구성을 해봐야 아무 소용이 없는 것이다. 이랬을 경우에는 거꾸로 SEO를 하기 위해서만 해야 하는가? 혹은 SEO가 더 중요한가? 사용자한테 빠르게 웹앱을 전달하는 게 중요한가?에 대해서 이제 선택을 해야 될 필요성도 있다.<br />
  상황에 따라서 모든 게 항상 고정적이진 않다. SSR이라고 해서 빠른 초기 로딩이 무조건 보장되는 것은 아니라는 이야기.
- 멀티 도메인 API 연동이 용이하다.<br />
  기본적으로 마이크로서비스화 된 서버가 있다고 했을 때, 클라이언트 사이드에서 호출이 일어나는 게 아니라 backend to backend로 통신이 이루어지기 때문에 보안상의 단점이라던가 혹은 복잡한 게이트 구성이라던가 이런 게 필요가 없다. 이런 측면에서 CSR보다 유리한 측면이 있다. <br />
  하지만, 실제로 복잡한 마이크로 서비스 같은 경우에는 이 멀티 도메인 API에 대응을 하기 위해서
  백엔드 사이드의 API가 많이 나눠지고, 결국 이 서버 사이드 렌더링 서버의 코드 복잡도가 올라갈 수 있는 문제들도 생긴다. 그래서 요즘은 BFF 같이 백엔드를 위한 프론트엔드라는 아키텍처가 도입되기도 하고 여러 가지 복잡해지는 부분이 있다.<br />
  결국 웹 서비스의 기능이 많아지고 서비스가 성장하면 어떤 아키텍처든 복잡도는 올라갈 수 밖에 없다는 측면을 알고 있는게 좋고, 모든 게 다 언제나 장점이 고정적으로 장점이고 단점이 언제나 단점이지 않다는 것은 항상 엔지니어가 갖고 있어야 할 생각인 것 같다.

단점

- 렌더링 백엔드가 필요하다.<br />
  렌더링 서버가 반드시 있어야 하는 SSR. 결국, 백엔드 서버의 운영 비용이 들어간다.<br />
  프론트엔드 개발자로서 프론트엔드를 개발하는데 백엔드가 무조건 필요하다는 것은 무슨 의미일까? 백엔드는 24시간 365일 서비스를 수행해야 하다보니 장애가 나면 안된다. 하지만 장애가 시간대에 맞춰서 나진 않는다. 새벽, 밥먹을 때, ... 등... 그러니까 내가 어느 상황에서든 내가 장애에 대한 대응을 기민하게 하기 위해서 무언가 해야한다는 것이다. 아키텍처에서도 그걸 고려해야하고, 어떤 장애가 났을 때 내가 최대한 빨리 알람을 받을 수 있는 아키텍처도 생각을 해야 되고 그런 것들이 추가 비용이 든다는 이야기다. (+ 클라우드 컴퓨팅의 가격)<br />
  그래서, SSR인 경우에 급격하게 트래픽이 늘어난다라고 했을 때 과연 SSR이 답인가? SEO로 인해서 우리가 얻는 베네핏과 서버를 운영하면서 얻는 단점. 이 두가지가 어떤 게 우리한테 더 이득인가를 판단해 봐야 된다. 그러므로 서비스 크기에 따라서는 이 두가지를 적절하게 고려해봐야 되는 측면들이 있다.
- 아키텍처가 조금 더 복잡하다.<br />
  이건 어떤 측면에서는 단점일 수도 있고 장점일 수도 있다. 여러 가지 복잡한 아키텍처. 즉, 여러 가지 기술 요소를 검토를 해야 된다는 이야기인데, 그거는 개발자에 따라서는 "재밌어!"라고 느낄 수도 있고 한편으로는 그냥 서비스만 놓고 본다고 하면 아키텍처가 복잡해진다는건 운용도 좀 복잡해지고 새로운 개발자가 들어오고 나갈 때에 대한 학습 비용이나 전달 비용도 높아진다라는 측면들이 있으니까 그런 것들은 또 단점이라 생각할 수도 있다.<br />
  그럼에도 불구하고 'Simple is Best'라고 하는 말도 있듯이, 단순한 게 가장 좋은 일이다.<br /> 최적의 서비스를 제공하면서 아키텍처도 단순해~ 그러면 훨씬 좋을 수 있는데, 그렇지 않다고 하는 건 단점으로 생각해 볼 수 있다. 같은 feature를 만들 때 서버 사이드 렌더링과 클라이언트 사이드 렌더링을 비교해 보면 SSR이 고려할 것도 많고, 복잡해지는 건 어쩔 수 없는 측면들이 좀 있는 것 같다.
- 트래픽 대응에 부담이 따른다.
  백엔드가 있다 보니까 당연히 트래픽에 대한 부담이 생길 수밖에 없다. 그래서 이건 정말 잘 고려해봐야 한다. <br />
  지금 당장 사용자한테 서비스하고 있는 현재 서비스가 엄청난 사용자를 갖고 있지 않다 하더라도 뭔가 이벤트 같은 것을 하게 돼서 이벤트가 굉장히 사용자한테 주는 메리트가 크다고 하면, 안 쓰던 사용자들도 급격하게 몰릴 수 있는 그런 상황들도 간혹가다 생길 수 있는데, 그런 상황에서 이 서비스를 그대로 이용한다고 하면 문제가 확(!) 생겨버릴 수 있는 것이다.

<br />

#### 선택의 시간 ⏰

사용자도 많지 않고 초기 단계의 '12#'...<br />
그래서 CSR보다 검색엔진에 최적화돼서 사용자한테 많이, 검색엔진에 많이 노출 되고 우선순위 있게 노출되는 것이 더 중요하다는 판단이 든다.<br />

이와 같은 근거로 우리의 선택은, ... `SSR`을 선택하는 것이. 맞다고 보여진다는 결론에 도달...<br />

그럼 이제 또 다른 기술 선택 사항이 있는지를 살펴보자.

<br />

### 선택 2. React SSR vs. Next.js

SSR을 선택했는데, ...SSR을 구현하기 위한 방법은 뭐가 있을까? (React를 사용한다는 전제)

#### React SSR - 학습용

#### Next.js - 실전용
