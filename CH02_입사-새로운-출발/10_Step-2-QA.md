## QA

```
1. 어떻게 테스트할 것인가
2. E2E 테스트 + 알파
3. Cypress
```

### 어떻게 테스트할 것인가?

단위 테스트 vs. 통합 테스트<br />

프론트엔드 개발이라고 하는 것이 서버 사이드 개발과 달리 자동화된 테스트를 만드는 데 있어서 훨씬 더 제약 사항이 많다고 보여진다.<br />
테스트 엔지니어링 관점에서 테스트의 대상을 결정하는 게 굉장히 중요한데, 어떤 것을 테스트하고, 어떤 것을 테스트하지 않을 것인가?<br />
테스트에서는 예외적인 것을 보통 많이 제외한다.<br /> 
예를 들면, 어떤 API를 호출해서 그 API가 반환하는 데이터 셋을 갖고 어떤 UI를 그리는 컴포넌트 혹은 애플리케이션이 있다고 가정했을 때,<br />
우리가 프론트엔드 앱을 테스트한다라고 하면 테스트 대상은 무엇이 될까? API가 테스트 대상이 될까? 컴포넌트가 테스트 대상이 될까?<br />

당연히(!) 컴포넌트는 테스트 대상이 된다. 그러면 그 API는 테스트 대상인가? 아마 아닐 것이다. <br />
그것은 다른 애플리케이션이고 그 API의 응답과 관련된 것을 테스트한다고 하면 테스트 범위는 완전히 광범위하게 넓어져 현대와 같이 백엔드 사이드가 MSA로 구성되어 있는 상황에서, 'API를 테스트 커버리지로 넣는다'고 하면 거의 모든 시스템을 다 테스트하는 상황이 돼 버리리기 때문이다. 그래서 말이 안되며, 이런 측면에서 API가 배제된다.<br />

그리고 네트워크도 언제나 성공을 보장해주는 상황이 아니기 때문에. 다시 말해, 예외가 언제나 발생하는 상황이기 때문에 순수하지 않은 환경인 것이다.<br />
그래서 테스트는 "실패를 위한 테스트는 언제나 실패해야 하고, 성공해야 하는 테스트는 언제나 성공"해야 한다. <br />
그리고 예외가 발생하는, 테스트를 시도했는데 이게 실패할 수도 있고 성공할 수도 있는데 그 실패 혹은 성공이 제어가 안되는 환경이면 문제가 있기 때문에 네트워크도 사실 테스트의 범위에 넣을 수는 없다.<br />

이렇게 되면 결국 컴포넌트와 UI가 그려지는 부분들만 남게 되는데, 나머지는 다 모킹을 하더라도 UI와 관련된 부분에 있어서는 우리가 어떤 식의 테스트를 해 볼 수 있을까...?<br />
예를 들면, 우리가 리액트로 컴포넌트를 만들었는데 그 리액트의 컴포넌트는 잘 작동이 됐다.<br />
그러면 브라우저에서 그려지는 최종적인 비주얼은 어디서 만들어질까?<br />
브라우저가 렌더링 한 결과가 사용자가 보는 최종적인 비주얼 결과다. 그런데 코드가 잘 작동됐다고 해서 "올바르게 비주얼이 표현(렌더링) 됐다"고 보증할 수 있을까? 당연히 안될 것이다. 레이아웃이 조금 깨지거나 혹은 브라우저 상황이나 디바이스 환경에 따라서 여러 가지 환경적 요인으로 인해서 렌더링이 100% 올바르다고 보장할 수 없다는 것이다.<br />

하지만 이렇게 되면 "네트워크와 마찬가지로 환경적 요인이 있는, 예외적인 상황이 되는 렌더링 환경이다."라고 하면 브라우저의 렌더링도 테스트 범위에 넣을 수 없다. 그럼 결국 리액트의 코드만이 테스트 범위가 될텐데, 코드가 잘 통과됐다고 해서 애플리케이션이 잘 그려졌다고 보장할 수 있을까? 뭔가 불안하다.<br />

이런 프론트엔드의 구조적 특성 때문에 단위 테스트를 얼마든지 많이 만들어낼 수 있는데,<br />
그 단위 테스트가 정말 실용적으로 "우리가 만드는 애플리케이션이 완전하다는 것을 얼마만큼 보장할 수 있는가?" 라는 측면에 개인적으로는 회의적인 부분들이 있고, 또 단위 테스트가 많이 만들어지면 만들어 질수록 프론트엔드의 변경에 대한 라이프 사이클은 서비스가 잘 되면 잘될 수록 굉장히 빈번해서 UI 컴포넌트들도 자주 업데이트 되어야 하고, 그거에 수반된 단위 테스트 코드들도 계속 유지관리 되어야 하기 때문에 그것 자체가 서비스를 운영함에 있어서 굉장히 큰 로드가 될 수도 있다.<br />

개인적으로는 단위 테스트를 너무 과도하게 구축했을 때, 얻을 수 있는 이득보다는 실이 훨씬 더 컸던 것 같다.<br />
한 개인의 생각이라고 볼 수도 있지만, 일정 규모 이상의 애플리케이션의 단위 테스트를 어마 무시하게 만들어 놓고 잘 운영했던 케이스를 거의 본 적이 없는 것 같다.<br />
사실, 본 적이 없다.<br />
그래서 굉장히 회의적으로 느끼고 잘 운영되던 것들도 테스트 케이스가 계속 업데이트 되는 게 어렵고 그러다보니까 테스트가 깨지고,<br />
그래서 그 수많은 테스트 케이스들이 그냥 사장되고 나중엔 괜히 부담으로만 계속 남고 이런 경우들을 훨씬 더 많이 봤기 때문에 애플리케이션 전체를 테스트하기 위한 단위 테스트에 회의적인 생각을 가지고 있다.<br />

그렇다면, "테스트에 대해서 회의적 것인가?".<br />
그건 아니다.<br />
지금의 생각은 기본적으로 테스트는 E2E 테스트, 즉 통합테스트를 기반으로 해야하는게 아닌가 하는 생각을 가지고 있다.<br />
프론트엔드 특성상 최종적으로 사용자한테 렌더링 되는 앱의 결과.<br />
그리고 앱들이 갖고 있는 기능들 단위로 테스트가 이루어지고 "그것이 올바로 작동되는가?"와 "시각적인 측면에서도 잘 렌더링 되는가?"라는 부분들도 E2E 테스트를 해볼 수 있는 부분들이 많이 있다.<br />
그래서 기본 테스트는 E2E 테스트를 기반으로 되야 한다고 생각한다.

<br />

### E2E 테스트

E2E 통합테스트라고 API까지 포함한 전체 시스템의 통합 테스트라기 보다는 프론트엔드가 맨 앞단에 있으니까, 맨 앞단에 앱이 작동되는 측면의 E2E 테스트를 말한다. 또, 이렇게 이야기를 한다고 단위 테스트가 전혀 필요업는게 아니라 핵심 비지니스 로직과 관련된 단위 테스트가 만들어지고 유지됐을 때, 우리한테 굉장히 많은 베네핏을 주는 그런 단위 테스트들도 분명히 존재하고, 즉, 핵심 로직 중심의 단위 테스트를 만들고 배포 파이프라인에 그 테스트 코드가 확인되는 것을 넣는 것. 이런 것들은 굉장히 중요하다.<br />
그래서 이 두 가지가 적절히 실용적으로 혼합되어서 구축되는 환경을 구축하기를 이야기하는 것이다.

<br />

### Cypress

```json
// /web/web1/package.json
{
  // (...)
  "test": "cypress open"
  // (...)
}
```

메인 화면<br />
<img width="400" alt="Cypress-Main" src="https://user-images.githubusercontent.com/19165916/194845340-0c326672-6485-482d-96e0-148d509a3329.png"><br />
E2E 테스트 메뉴 진입 화면<br />
<img width="400" alt="Cypress-run-chrome" src="https://user-images.githubusercontent.com/19165916/194845326-e4fd3d73-7621-496a-b5b9-aa39a9e01a32.png"><br />

- 확장자명은 `cy.js`
- `1-getting-started`나 `2-advanced-examples`는 cypress 자체적으로 만든 튜토리얼 문서

실행결과 :)<br />
<img width="400" alt="result" src="https://user-images.githubusercontent.com/19165916/194845993-14cac8f8-9728-4549-a2e6-4f7492fdb7ad.png">

<br />

E2E 테스트를 아주 간편하게 작성할 수 있게 해주고 코드로도 작성할 수 있고, 어떤 특정한 기능을 레코딩(!)을 해서, 레코딩 한 것을 리플레이 하면서 똑같이 동작하는지를 테스트를 할 수도 있다.<br />

또 스냅샷을 뜰수도 있다. 이전의 스냅샷과 현재의 스냅샷을 비교해 시각적으로 변화가 있는지도 확인해볼 수 있는 시스템을 만들수도 있다. 이미지대 이미지로 비교할 수 있다. 코드만 가지고 렌더링 부분의 테스트를 완벽하게 하기 힘든 측면들이 있는데 이미지로 비교 한다면 이런 부분들도 해소할 수 있는 여지가 생기는 것이다. 다시 말해, 컴포넌트의 렌더링에 대한 테스트도 가능하다는 것이다.<br />

```js
describe("12shop", () => {
  context("아이폰X 뷰포트", () => {
    beforeEach(() => {
      cy.viewport("iphone-x");
    });

    it("load", () => {
      cy.visit("http://www.12shop.com:7070");
    });

    it("displays full header", () => {
      cy.title().should("eq", "12shop.com 으로 오세요");
    });

    it("og tag", () => {
      cy.get('meta[property="og:url"]');
      cy.get('meta[property="og:type"]');
      cy.get('meta[property="og:title"]');
      cy.get('meta[property="og:description"]');
      cy.get('meta[property="og:image"]');
    });

    it("twitter card", () => {
      cy.get('meta[name="twitter:card"]');
      cy.get('meta[name="twitter:site"]');
      cy.get('meta[name="twitter:creator"]');
    });
  });
});
```

> 외 앞서 말한 레코딩 방식의 테스트도 가능하다. :) <br />

테스트는 당연히 필요하다. 그리고 QA를 하시는 분들이 있다면 그 분들이 수동 테스트든 자동 테스드든 뭔가 테스트를 할 것이다.<br />
하지만 이렇게 개발자가 엔드 투 엔드 테스트의 상당 부분을 작성 해 놓으면, 특별한 케이스가 아니라면 수동으로 사람이 테스트하는 부분에 거의 90% 이상은 이 테스트로 커버가 됐다. 그러면 엄청난 시간과 인력, 자원들을 절약할 수 있도록 기여할 수 있을 것이다.<br />
그리고 무엇보다 이렇게 테스트가 잘 구축되어 있으면, 우리가 애플리케이션의 변화에 대해서도 안정적으로 릴리즈 할 수 있고 불안하지 않을 것이다.<br />

그런 측면에서 이러한 테스트들은 현실적으로 그냥 막연히, 'TDD는 엔지니어라면 무조건 해야 한다'는 것에 너무 몰입해서 정말 이 테스트 방식이 우리한테 효과적인지 효과적이지 않는지 혹은 '실제로 작성은 많이 되어 있는데 우리한테 얻는 이득은 별로 없는 방법인지'와 같은 부분들을 현실적으로 한번 고민을 해 봐도 좋을 것 같다.<br />

"단위테스트는 못해도 E2E 테스트는 꼭 했으면 좋겠다. 😅"
