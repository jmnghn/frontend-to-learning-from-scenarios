## 컴포넌트 저장소 분리하기

컴포넌트 저장소 분리와 관련된 주제는 최근에 굉장히 많은 분들이 관심을 갖고 있는 분야이고 또 많이 시도해보고 있는 그런 부분인 것 같다. 그런데 이걸 해보면, 굉장히 많은 문제들이 있고 고려해야 될 점들이 꽤 많이 있다. 기술적인 부분에 있어서 고려한다고 하는 것은 우리가 학습을 해서 실제로 시도해보고 문제가 없는지 확인해보고, 또 문제가 있는 것들은 해결을 하면 되는데 문제는 이게 일하는 방식과도 연관되어 있는 것이기 때문에 굉장히 까다로운 지점들이 많이 있다.<br />
그래서 "미리 어떤 부분들이 고려해야 할 포인트들이 있는가를 인지하고 있는 것이 굉장히 중요할까?"와 관련한 이야기 :)

```
1. 컴포넌트의 스코프
2. 프로젝트 스코프
3. 저장소 분리 방법
```

사실 내용은 굉장히 단순하다. 말 그대로 컴포넌트의 저장소를 분리하는 것. 그 뿐이다.<br />
"컴포넌트의 저장소를 분리한다는 건 어떤 이야기일까?" 🤔<br />
우리가 저장소. 즉, 깃 리파지토리의 기준은 보통 Product를 기준으로 만드는데, 그렇기 때문에 그 Product안에 컴포넌트가 당연히 있겠고, 그 Product 리파지토리에서 분리하자는 이야기다. (굉장히 심플) <br />

그런데, "왜 분리를 해야 하는가?"에 대한 게 주제가 될 것이다.<br />
이 분리에 대한 당위성을 이해하기 위해선 컴포넌트의 스코프에 대한 이해가 좀 필요하다.<br />
컴포넌트의 스코프/변수의 스코프/객체의 스코프에 대한 이야기들은 굉장히 많이 하는데, "컴포넌트의 스코프라고 하는 건 어떤걸까?"<br />

### 컴포넌트의 스코프

'컴포넌트가 어디까지 알려지고 어디까지 사용되어지는가'가 컴포넌트의 스코프라고 하는 주제일 것이다.<br />
컴포넌트가 어디에 쓰이는지를 먼저 알아보자. "어디에 쓰일까?"<br />

굉장히 광범위한 영역에 쓰인다. 개념적으로 한번 나눠보면,

- 서비스<br />
  가장 큰 범주는 당연히 서비스일 것이다.
- 애플리케이션(or 프로덕트)
- 프로젝트<br />
  프로덕트를 만들기 위해서 프로젝트가 발생할 수도 있는거고, 새로운 프로덕트를 위해서 프로젝트가 발생할 수도 있는. 정확하게는 라이프 사이클이라고 하는 관점에서 좀 다르다. 프로덕트의 라이프 사이클이 훨씬 길고, 프로젝트는 라이프 사이클이 짧고. 어떤 특정한 목표가 완성되면 그 프로젝트는 사라지고, 새로운 프로젝트가 시작되고 하는 맥락에서 명백히 다르다. 이걸 굳이 넣어 놓은 이유는 프로젝트를 하면서 사람이 바뀌고, 혹은 그 프로젝트를 하기 위해서 참여한 사람들에 따라서 기존에 있는 컴포넌트를 재사용되지 못하고 새롭게 만드는 경우들도 굉장히 비일비재하기 때문에 한번 넣어봤다. ^^;<br />
  프로젝트의 라이프 사이클이 굉장히 짧은데, 그 프로젝트가 생길 때마다 새로운 컴포넌트가 생길 수 있고 또 다른 그 다음 프로젝트에선 그 전에 프로젝트에서 만들었던 컴포넌트를 어떤 이유로 못쓰는 이유들도 생기고 이러면 스코프 자체가 프로젝트에 한정되니까 문제가 많은 개발 방식이 되는 것이다.<br />
- 페이지(or 스크린)<br />
  페이지(or 스크린) 안에서만 쓰이는 한정적인 컴포넌트도 존재할 수 있는 것들이다.<br />
  특정한 페이지에서만 사용되고, 그 페이지를 벗어나면 사용할 수 없는 컴포넌트들. 본 적도 있을거고 상황에따라 만들어 본적도 있을 것이다. ^^;<br />

컴포넌트의 스코프가 이렇게 여러가지의 스코프를 가질 수 있는데, 가장 이상적으로 가져야 되는 컴포넌트 스코프는 어디일까? 애플리케이션 혹은 프로젝트 혹은 서비스? 어디일까? '이상적인 관점'으로서 말이다.<br /> 그렇다면 당연히 서비스 스코프를 가져야 한다고 생각을 한다. 서비스. 즉, 사용자 접점에 있는거다. 사용자는 프로덕트나 프로젝트라기보단 서비스를 사용하는 거니까 당연히 서비스 내에서 일관성 있는 UX를 제공을 해야 하는데. 즉, UX를 미시적인 관점에서 구성하고 있는 구성요소는 컴포넌트라고 할 수 있는데, 그럼 그 컴포넌트가 당연히 일관되어야 할 것이다. 이런 일관성을 유지하기 위해선 당연히 물리적으로 동일한 컴포넌트로 만들어 놓으면 일관성을 당연히 유지할 수가 있을 것이다. 그렇기 때문에 '서비스 범위 안에서 스코프를 갖고, 그 서비스 범위로 컴포넌트를 만들고 그리고 그 컴포넌트를 애플리케이션에서 즉, 프로젝트, 프로덕트에서 재사용할 수 있는 가져다 쓰는 방식으로 만들어 놓는 것이 가장 이상적이다' 라는 것이다.<br />

그러면 그 이상적인 부분. 이상을 실현하기 위해선 어떤 방법이 있는가를 보자면, 리파지토리를 분리하는 게 첫 번째 해야하는 일인 것이다. 리파지토리가 분리되지 않으면 자연스럽게 프로젝트 혹은 프로덕트 디펜던시(dependency)가 생길 수 밖에 없는 것이다.<br />

예를 들어 보자면,<br />

<br />

### 프로젝트 스코프 (eg. webview1)

`webview1` 프로젝트는 우리가 쇼케이스라고 하는 웹앱을 만들기 위해서 프로젝트를 시작했고, 그 프로젝트의 결과로 나온 프로덕트다. 그 프로젝트의 리파지토리를 한번 보자면, 어떤 스코프를 갖게 될까?<br />

<img width="400" src="https://user-images.githubusercontent.com/19165916/195278546-e94e7e7b-afe6-47c9-a8e7-b31880ecd2ab.png">

webview1이라고 하는 프로젝트의 스코프를 갖게 될 것이다.<br />

우리가 크게 의식하지 않아도 프로젝트 리파지토리 같이 컴포넌트가 있으면, 당연히 그 프로덕의 프로젝트 스코프를 갖게 되고 그렇게 개발되다 보면 당연히(!) 이 컴포넌트의 스코프는 이 `webview1`에 갇힐 수 밖에 없는 구조다. 디펜던시도 자연스럽게 부지불식간에 생길 수 밖에 없고, 그래서 우리가 `webview2` 혹은 오더리스트라고 하는 프로젝트를 새로 만들어야 한다면, 당연히 프로젝트 리파지토리를 생성할 테고 그 리파지토리에 우리가 아까 봤던 SearchInput 같은 컴포넌트가 또 있어서 그걸 가져다 쓰려고 하면, 쓸 수 있을까? 쓰지 못할 것이다. 왜냐하면 '이 `webview1` 프로젝트 안에 있는 컴포넌트는 외부의 다른 리파지토리에서 컴포넌트를 가져다 쓸 수 있는 어떤 준비도 되어 있지 않기 때문에' 자연스럽게 SearchInput을 또 만들수 밖에 없다. 이건 굉장히 자연스럽고, 아마 끊임없이 해오던 일일 것이다. 저쪽 프로젝트에 비슷한 컴포넌트가 있는데 가져다 쓸 수 없으니까 또 만들거나 심지어는 있는지 관심도 없다. 사실 늘 유사한 컴포넌트를 우리는 계속 만들고 있고, 그게 개발자의 잘못이라기 보다는 우리가 사용하는 대부분의 웹 프레임워크. 리액트든 뷰든 프로젝트 베이스 안에서 컴포넌트를 만들게 되어 있고, 그 컴포넌트를 특별한 의식이 없으면 당연히 그 스코프 안에 존재할 수밖에 없다. 그렇기 때문에 재사용성을 추구하는 컴포넌트라고 하는 아키텍처가 무색한 측면들이 좀 있는 것이다.<br />

그래서 '프로젝트 범위를 벗어나는 스코프를 만들기 위해선 개발자의 의도적인 활동이 필요하다.' 이야기다. '그 의도적인 활동이 바로 컴포넌트 repo를 분리하자'라고 하는 것이다.<br />
"어떻게 분리할 수 있을까?"<br />

<br />

### 저장소 분리 방법

일단, 저장소를 분리하는 방법은 굉장히 심플하다. 컴포넌트 repo를 분리해서 새로운 저장소를 만들고, 거기에는 우리가 필요로 하는 컴포넌트를 만들면 된다.<br />
예제 코드를 살펴보자.

<img width="240" src="https://user-images.githubusercontent.com/19165916/195285314-db519e1e-24f4-4444-b490-69d227e73eb3.png"><br />

`/12shop-compoentns/src` 하위에 많이 보던(!) 컴포넌트들이 보일 것이다. 그 외에 구성요소들이 없다. 애플리케이션이라던가 상태와 관련된 어떤 것들이라던가 하는 것들이 전혀 없이 오로지 컴포넌트만 존재하는 리파지토리인 것이다.<br />
그럼 이걸 다른 프로젝트에서 가져다 쓰려면 어떻게 해야할까?<br />

#### git

```
git submodule add https://github.com/.../12shop-components
```

git submodule<br />
\: 마치 심볼릭 링크 같이 `webview1` 프로젝트 하위에 컴포넌트 폴더를 만드는 데, 그 컴포넌트 폴더의 원본은 실제로 다른 깃 리파지토리에 있는 것이다. 그래서 '`webview1` 컴포넌트 내에서는 특정한 폴더가 마치 있는 것처럼 프로젝트가 구조화'되고, 그 안에 있는 내용물은 리모트에 있는 다른 리파지토리에 있는 것이다.<br />

그래서 위 명령어와 같이 `git submodule add`하고, 컴포넌트 repo를 추가해 놓으면 저장소가 분리되어 있는 상태에서 그 컴포넌트가 마치 로컬에 있는 컴포넌트 폴더처럼 사용을 할 수 있다. 이렇게 간단하게 해볼 수 있는데, 이 구성의 단점은 당연히 존재한다.<br />

리모트에 있는 컴포넌트의 업데이트를 받게 될 때, 버저닝(versioning)에 대한 부분들을 만들어낼 수 없고, 항상 현재 버전을 pull 받아서 업데이트를 한 후에 개발을 해야 되는 문제들이 있다. 어떤 컴포넌트들은 현재 개발중인 컴포넌트여서 Product에서 쓰이면 안되는 상태가 있을 수도 있다. 그래서 그걸 버저닝으로 처리하면 좋겠는데, 이 서브 모듈 같은 경우는 그런 처리들이 안 되고 그냥 링크만 붙여놓은 상태니까 굉장히 좀 제한적이다. 심플하게는 해볼 수 있겠지만, 그렇게 추천하는 방법은 아니고 다른 측면에서는 굉장히 유리할 수 있겠지만, 컴포넌트 리모트를 분리하는 방법으로는 아주 제한적인 방법이니까 우리들이 이 방법으로 Product를 운영해 나간다고 하면 현실적으로 여러가지 문제점에 부딪힐 것이다. 처음엔 아주 심플하게 돼서 쉽게 되는 것 같아 보이지만, 문제들이 많은 방법이고, 크게 권장되는 방법은 아니다.

<br />

#### npm - private (eg. [verdaccio](https://verdaccio.org/))

권장되는 방법은 npm이라고 하는 저장소에 등록을 해서 12shop 컴포넌트 repo를 퍼블리싱을 해놓고 (결국은. 라이브러리니까) 저장소에 등록을 해놓고 그것을 다른 리액트나 차크라UI나 뭐 이런 형태의 패키지들처럼 사용하고자 하는 Product에서 가져다가 쓰는 것이다.<br />

하지만, 당연히 우리가쓰는 public npm. 우리가 사용하는 npmjs.org 에다가 등록을 시킬 순 없을 것이다. 우리 서비스에서만 쓰는 컴포넌트니까. private 리파지토리를 구축해서 사용을 하면 된다. private 리파지토리를 구축하는 방법은 여러 가지가 있는데, 많이 쓰는 것중에 하나가 verdaccio라고 하는 것이 있다. 이를 사용해서 private 레파지토리를 구축해서 사용해도 되고, 혹은 다른 것들을 써도 된다. 크게 문제는 없다. 중요한건 npm과 완벽하게 호환되는 솔루션을 가져다가 쓰면 훨씬 더 편하다는 것. 그러면 컴포넌트의 버저닝이라던가 다양한 측면에서 다른 패키지들처럼 유용하게 사용할 수 있다라는 것이다.<br />

이렇게 기본적으로 패키지를 분리해 놓으면 어떤 효과가 있을까?<br />

자연스럽게 컴포넌트를 개발하는 개발자들이 스코프 자체가 프로덕 프로젝트 스코프가 아닌 서비스 스코프로 확장될 수밖에 없기 때문에 업무적으로 분리가 될 수 밖에 없다. '12shop'에서 UI를 구축하는데, 당연히 컴포넌트들이 많이 필요하고 그 컴포넌트들이 이미 컴포넌트 리파지토리에 들어있다면, 어떤 게 있는지 살펴볼 수 있고, 선별적으로 가져다 쓸 수도 있는 측면들이 있고, 그 컴포넌트는 당연히 A라는 프로젝트에서도 쓰게 되고 B라는 프로젝트에서도 쓰게 되니까 컴포넌트를 만들 때에도 프로젝트 혹은 프로덕 디펜던시에 대한 고려를 할 수밖에 없다. 컴포넌트를 개발할 때 자연스럽게 재사용성에 대한 부분들을 훨씬 더 맣이 고민할 수밖에 없다. 그리고 앞에서 이야기 했던 용어에 대한 통일 같은 것들도 자연스럽게 이루어질 수밖에 없다. 왜냐하면 같은 컴포넌트를 여러 군데 사용하니까 말이다.<br />

그래서 이렇게 분리된 구조를 만드는 것 자체만으로도 굉장히 다양한 효과들을 볼 수 있다.<br />
초기부터 이렇게 구축해놓고 컴포넌트를 개발하는 것을 추천을 하는데, 나중에 가서 프로젝트가 굉장히 많이 생기고 거기서 실제로 서비스 관점에서는 똑같은 동일한 컴포넌트인데 동작도 미묘하게 다르고, UX도 미묘하게 UI도 미묘하게 다른 걸 통일하고 싶을 때, "컴포넌트를 분리하자!"해서 컴포넌트를 다 끌어모아서 한쪽에 다 모은다고 했을 때, 굉장히 많은 허들이 생긴다. 왜냐하면 프로젝트를 진행하는 각 팀들의 이해관계가 얽히기 때문이다. 기존의 방법(기존의 프로젝트 스코프 안에서)보다 npm에서 끌어다 쓰는 게 훨씬 불편할 것이다. 그러니까 기존에 뭔가 바쁜 데 이걸 또 하기 위해서 부가적으로 해야 한다라고 하면, 당연히 기존의 팀들의 저항에 부딪힐 수 밖에 없다. 그 저항들을 전부 다 풀어서 하나로 통일된 방식으로 이끌어가기엔 훨씬 더 많은 조직적인 에너지가 들어간다. 이런 에너지를 초기에 미리 이렇게 세팅해버리면, 나중에 그런 에너지를 쓸 필요가 없는 것이다. 왜냐하면 이미 새로운 프로젝트라고 할 때, 당연히 기본 셋업으로 들어가는 거기 때문에 자연스럽게 조직 운영성도 좋아진다는 측면에서 우리가 만약에 초기 상태라고 하면, 초기부터 리파지토리를 분리해놓고 컴포넌트를 개발하는 걸로 추천을 한다.<br />

다시 `12shop-components` 프로젝트의 package.json을 보면 롤업(rollup)으로 번들링이 되게끔 되어 있다. 기존에는 CRA를 써서 웹팩으로 번들링을 하고 있는데, 이런 라이브러리성 프로젝트들은 웹팩으로 쓰는 것보다 롤업으로 번들링을 하는 구축을 해놓는 것이 훨씬 이점이 많다. 빌드도 빠르게 되는 측면들도 있고,
번들링에서 배포하는 타입을 다양하게 아웃풋을 만들어 낼 수 있다.<br />

대표적으로 웹팩은 'CommonJS'로 아웃풋을 만들어낼 수 있는데, 롤업은 'CommonJS'뿐만 아니라 'ESM'방식으로도 모듈을 번들링 할 수 있는 기능들을 기본적으로 제공하기 때문이다. 그리고 코드 스플릿팅과 관련돼서도 훨씬 더 강력한 기능들을 많이 제공을 한다. 그래서 롤업이 서비스/Product 관점에 번들러로는 웹팩이 훨씬 더 많이 쓰이지만, 라이브러리 관점의 번들러로는 롤업을 굉장히 많이 쓴다. 그래서 이와같은 리파지토리를 구성을 할 때, 번들러는 롤업으로 세팅을 하면 여러 가지. 당장은 효용성을 못 느낀다 하더라도 나중에 규모가 커지고 여러 가지 요구사항들이 프로젝트마다 생겼을 때, 대응하기가 훨씬 용이하니까 라이브러리성 리파지토리의 번들러는 롤업을 사용해보기를 추천한다.<br />

모든 것이 다 분리된다는 게 좋은 것은 아니지만, 컴포넌트만은 아주 초기부터 셋업의 저장소를 분리해놓고 개발하기를 꼭 당부하고, 여러 가지 장점이 있으니까 그 장점들을 누려보기를... :)
