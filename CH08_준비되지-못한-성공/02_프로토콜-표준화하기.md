## 프로토콜 표준화하기

```
1. 메세지 표준이 없다면?
2. 케이스 스터디
3. 해결책
```

성공을 위한 준비. 꼭 하나만 준비해야한다고 하면 바로 이걸 준비할 것이다. 그리고 만약 어떤 조직아니 스타트업에 들어간다고 하면 당연히 이것부터 할 것이다. 나중에 됐을 때, 굉장히 바꾸기가 어렵다. 바로 '프로토콜 표준화'와 관련된 이야기다.<br />

프로토콜 표준화. 프로토콜 이라고하는게 뭘까?<br />
우리가 프론트엔드 입장에서는 클라이언트를 개발을 한다. 웹 클라이언트를 개발을 하는데, 당연히 모든 데이터는 서버로부터 받게 된다. 근데 서버가 N개다. 여러 가지 서버들이 많다. 그러면 서버와 클라이언트 간에는 데이터를 주고받는데 특정한 약속된 포맷으로 데이터를 주고받게 되고, 그 포맷이 서버마다 달라진다면 클라이언트의 입장에서는 굉장히 피곤하게 코드를 구성해야 하는 측면들이 있다. 메세지가 통일되지 않으면 굉장히 힘든 것이다. 즉, 그 메시지, 포맷, 그리고 주고 받는 형식과 그 안에 여러 가지 사용되는 단어나 워딩과 같은 부분들이 모두 다 제각각이라고 했을 때, 클라이언트 코드는 쓸데없이 지저분해지고 복잡해지고 유지보수하기 어려운 구조로 만들어질 수밖에 없다. 그런데 이걸 초기에 어떤 표준이 없는 상태로 그대로 두면 거의 필연적으로 그렇게 분화되어 갔었다. 안 좋은 쪽으로 말이다. 그래서 어떤 케이스가 있는지 한번 살펴보자.<br />

<br />

### 메시지 표준이 없다면?

> MSA 서버 환경에서는 필연적으로 발생한다.

사내에 메세지 표준이 없다면, 어떤 일들이 벌어질까?<br />
회사가 성장한다고 하면, 회사가 성장하는건 좋은거니까 MSA로 자연스럽게 여러 가지 서버들이 늘어날 것이다. 그러면 새로운 개발자와 팀들이 막 셋업이 되고, 규모들이 막(!) 늘어난다. 그래서 이 서버도 분화되고 저 서버도 분화되고... 예전엔 하나의 서버였는데 그게 여러 프로젝트들이 막 만들어진다. 그러면 필연적으로 이런 상황들이 생긴다.<br />

#### Case 1. b2c-server

![]()<br />

첫 번째, 제일 중요한 B2C API의 서버.<br />
이 B2C API 서버는 위와 같은 응답구조를 가지고 있다. `/product`를 호출한 응답인데, 당연히 상품의 객체를 배열에 담아서 response해주고 있다. 그런데 이것의 클라이언트는 뭘까? 웹뷰다. 쇼케이스 웹앱에서 이 B2C서버의 API를 호출해서 UI를 그리고 있는데, 그 쇼케이스 웹앱에서 API를 호출하면 응답이 어떻게 오는지. Case 2다.

#### Case 2. webview1

![]()<br />

이렇게 온다. 구조가 다르다. webview1 이라고 하는 쇼케이스 웹앱의 API 호출의 응답은 위와 같이 온다. 객체가 먼저 최상위 루트로 구성되어 있고 여기에 status, statusCode, error, result라고 하는 배열이 있고, result 안에 응답 데이터가 들어가 있다. 아까 Case 1에 있었던 구조가 이 Case 2 에서는 result라고 하는 형태로 한 depth 더 들어가있다. 중요한 건 메세지 포맷이 다르다고 하는 것이다.

#### Case 3. remote-config

![]()<br />

Case 3는 remote config 서버다.<br />
remote config 서버는 응답 구조가 위와 같다. Case 2와 굉장히 비슷하다. status, statusCode, data와 그 하위에 config, metadata, server 이런 식으로 되어 있는데, config 부터 시작되는 부분들은 그 도메인 서버의 고유한 영역의 특성을 그대로 갖고 있으니까 당연히 포맷이 다를 수밖에 없다. 그런데 그 상위의 구조인 status, statusCode, data와 같은 경우는 통일을 할 수 있으면 좋을 것이다.<br />

그리고 더 보면 얼핏 Case 2와 비슷한데, 또 다르다. 여기는 status와 statusCode는 같지만 result가 없고, result 대신 data가 있다. 그러니까 이것도 미묘하지만 구조가 다르다라는 것이다.<br />

클라이언트 입장에서는 만약에 하나의 클라이언트가 remote config도 사용하고 이 `/product` 코드도 사용한다고 하면, 엔드 포인트의 응답 구조가 다르기 때문에 그거에 대한 처리 코드가 당연히 수반되어야 한다. 어떻게 보면 같은 구조라고 하면 하나로 통일을 할 수 있을 텐데 구조가 다르니까 또 그 예외 처리를 해야 되는 것과 같은 생각만해도 좀 피곤한 상황들이 생긴다.

#### Case 4. Error

![]()

이거는 또 굉장히 피곤한 일 중의 하나다. 오류와 관련된 핸들링도 서버팀들마다 또 가치관이 좀 다르기 때문에 여러 가지 문제들이 생기는 경우가 있다. 대표적으로 프론트엔드 개발자들은 이런 이상향을 원한다. http status code 규약에 맞춰서 서버가 응답을 해줬으면 좋겠어라는 것이다. 사실 소박한 요구 사항이기도 하다. 성공을 하면 200번대 코드가 내려오고, 서버의 어떤 논리적인 오류가 있다면 400번대 코드가 내려오고 물리적으로 오류가 있다거나 혹은 알 수 없는 오류가 있다면 500번대 오류가 내려오면 좋겠어. 라고 하는 어떻게 보면 당연하다라고 할 수 있는데 상황에 따라서 위와같이 응답인 ㅐ려오는 경우가 있더라는 것이다.<br />

위 코드를 보면, `status: "ERROR"`인데 에러코드가 200이다. http의 성공 코드인 200코드가 내려오고 data 안에 error의 description이 들어가 있다. 이런 경우에는 우리가 axios 같은 툴들을 사용하게 되고, 혹은 fetch API와 같은 것들을 사용하게 되면 실제로 서버가 오류를 냈는데도 불구하고 예외로 빠지질 않는다. 결국 Promise의 reject로 빠지지 못하고, Promise의 fulfilled 구조로 된다. 그러면 결국 데이터를 까보고 에러인지 아닌지를 체크하는 로직이 들어가야 한다. 설상가상으로 같은 클라이언트 내에서 어떤 API 엔드포인트는 http status code 규약을 그대로 따르고, 어떤 서버에서 오는 데이터는 그 규약을 따르지 않고 모두 다 응답은 200이지만 오류일수도 있고 아닐수도 있어서 그러면 클라이언트의 로직 자체가 분리되어야 되는 똑같은 네트워크 로직인데도 불구하고 분리되어야 하는 문제가 생기는 것이다. 얘기를 하다보니까 하면서도 열이 좀 받는 느낌이 든다. (ㅋㅋ)<br />

그런데 이 상황들이 예외적인 상황들이 아니라 은근히 이런 식으로 처리하는 서버 개발자들이 꽤 있다. 실제로 만나본 사람들도 있을 것이고 경험해 본 사람들도 꽤 있을 것이다. 오죽하면 이런 케이스를 이야기를 할까. 그러니까 이런 상황이 만들어지지 않으려면 미리 작은 상태에서 '우리 회사의 메세지 프로토콜은 이렇습니다' 라고 통일된 규격을 만들어놓고, 모든 팀들이 그걸 따르게 한다고 하면 클라이언트 입장에서 훨씬 좋을 것이다. 그런데 그게 없으면 우리가 인지하지 못하는 순간 이런 시스템들이 생긴다라고 하는 것이다.<br />

그러면 대책은 뭐가 있을까?

<br />

### 해결책

이미 여기서 해결책이라는 것은 앞에서 얘기했듯이 아주 초기 상태의 스탠다드를 만들어 놓으면 가장 좋은 해결책이고 가장 좋은데 문제는 그러지
못하고 새로 이직을 해서 입사를 했는데 그 회사에 표준이 없고 규모가 되게 크고, 성장도 했고, 시스템도 굉장히 많은 그런 상황에서 표준을 갑자기 들이밀고 이걸 표준으로 하고 기존걸 다 바꿔보자고 했을 때, 그게 쉽게 워킹되지 않는다라고 하는 것이다. 오히려 갈등만 생기고 사람들간의 사이만 안좋아질 수 있으니까. 그런 상황에서의 해결책은 뭘까?<br />
두 가지 방법이 있을 수 있다.

#### 서버 표준 도입 vs. 클라이언트 표준 도입

서버의 표준을 도입하는 방법이 있고, 클라이언트에 표준을 도입하는 방법이 있을 것 같다. 어떤게 더 쉬울까? 그리고 규모가 있고, 이미 벌어진 상황에선 어떤 해결책이 정답일까?<br />

개인적인 생각으로는 당연히 클라이언트 사이드에서 표준을 도입해서 처리하는 것이 정답일 것 같다.<br />
여기에서 클라이언트 사이드에 표준이라고 하면 어떤걸까? 메세지 포맷. 즉, 메세지 프로토콜이 포맷과 스키마까지 포함해서 단일 프로토콜이어야 클라이언트 사이드에서 일관된 코드를 작성할 수 있게 된다고 하는 것이다. 예외적인 코드를 작성하는 것을 자꾸 하지않고 말이다. 에외적인 코드들을 계속 만들어가지 않고, 일관된 코드를 만들게 된다고 하면 그런 처리는 또 공통화해서 뺄 수도 있으니까 훨씬 더 효과적으로 중요한 코드에 우리가 비지니스 개발을 하는 데 더 많은 노력을 들일 수 있는 환경이 만들어진다고 하는 것이다.<br />
이와 같은 측면에서 클라이언트 코드의 표준을 한번 만들어보자. 클라이언트의
통일화된 코드를 만들 수 있는 시스템 구조를 만들자.가 바로 클라이언트 표준 도입이다.<br />
어떤 방법이 있을까?<br />

### BFF

> Backend For Frontend

대표적으로 요즘 많이 어프로치 하고있는 BFF를 예로들수 있을 것 같다.<br />
'Backend For Frontend'. 그러니까 프론트엔드 만을 위한 백엔드서비스를 만드는 것. 바로 이게 개인적으로 생각했을 땐 가장 효과적인 안일 것 같다. 이 BFF라고 하는 건 개인적으로는 예전부터 있었는데 언젠가부터는 그럴싸한 말을 만들어서 이런 문제점들을 명확하게 적시하고 해결책으로 제시된 것 같다. 그래서 이렇게 용어가 생긴다는 건 한편으로는 굉장히 좋은 것 같다. 용어를 잘 만드시는 분들 아주 존경스러운 마음을 전달해주고 싶은 그런 생각이 좀 드는데, 어쨌든 요즘 'Backend For Frontend'가 화두이기도 하다. 그래서 'Backend For Frontend'라고 하는 것은 '백엔드사이드의 메세지 규격을 통일화 시키지 못하니까 결국 그것들을 받아서 프론트엔드한테 보내주는 부분들을 통일화시켜보자' 라고 하는 컨셉이라고 생각하면 된다.<br /> 그 외에도 미시적인 관점에서 여러 가지 피처들이 좀 있긴 하지만 우리 지금 논의되는 주제는 메시지 프로토콜과 관련된 부분이니까 그것과 한정돼서 한번 어떤 식으로 BFF를 구성하면 좋을지 다음 세션에서는 실질적인 구현 예를 좀 보면서 이야기를 좀 더 나눠보도록 하자.
